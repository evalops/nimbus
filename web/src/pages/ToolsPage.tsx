import { useMemo, useState } from "react";

import "./ToolsPage.css";

interface RoiInputs {
  runsPerDay: number;
  avgRuntimeMins: number;
  ghMinuteCost: number;
  nimbusMinuteCost: number;
  hardwareCostPerHour: number;
  ghQueueLatencyMins: number;
  nimbusQueueLatencyMins: number;
}

interface RoiResult {
  ghMonthlyCost: number;
  nimbusMonthlyCost: number;
  annualSavings: number;
  timeSavedPerEval: number;
  breakevenLabel: string;
}

interface CostPoint {
  runsPerDay: number;
  ghMonthly: number;
  nimbusMonthly: number;
}

interface TerraformSuggestion {
  desiredCapacity: number;
  comment: string;
  snippet: string;
}

const DEFAULT_INPUTS: RoiInputs = {
  runsPerDay: 180,
  avgRuntimeMins: 12,
  ghMinuteCost: 0.008,
  nimbusMinuteCost: 0.0025,
  hardwareCostPerHour: 4,
  ghQueueLatencyMins: 5,
  nimbusQueueLatencyMins: 1,
};

export function ToolsPage() {
  const [inputs, setInputs] = useState<RoiInputs>(DEFAULT_INPUTS);

  const result = useMemo<RoiResult>(() => {
    const minutesPerDay = inputs.runsPerDay * inputs.avgRuntimeMins;
    const ghDailyCost = minutesPerDay * inputs.ghMinuteCost;
    const ghMonthlyCost = ghDailyCost * 30;

    const nimbusComputeDaily = minutesPerDay * inputs.nimbusMinuteCost;
    const nimbusHardwareDaily = (minutesPerDay / 60) * inputs.hardwareCostPerHour;
    const nimbusMonthlyCost = (nimbusComputeDaily + nimbusHardwareDaily) * 30;

    const annualSavings = (ghMonthlyCost - nimbusMonthlyCost) * 12;
    const timeSavedPerEval = Math.max(inputs.ghQueueLatencyMins - inputs.nimbusQueueLatencyMins, 0);

    const ghPerEval = inputs.avgRuntimeMins * inputs.ghMinuteCost;
    const nimbusPerEval = inputs.avgRuntimeMins * inputs.nimbusMinuteCost +
      (inputs.avgRuntimeMins / 60) * inputs.hardwareCostPerHour;

    let breakevenLabel = "Equal cost per eval";
    if (nimbusPerEval > ghPerEval) {
      breakevenLabel = "Nimbus more expensive per eval (adjust inputs)";
    } else if (nimbusPerEval < ghPerEval) {
      breakevenLabel = "Immediate savings";
    }

    return {
      ghMonthlyCost,
      nimbusMonthlyCost,
      annualSavings,
      timeSavedPerEval,
      breakevenLabel,
    };
  }, [inputs]);

  const series = useMemo<CostPoint[]>(() => {
    const points: CostPoint[] = [];
    const maxRuns = Math.max(inputs.runsPerDay * 1.5, 60);
    const step = Math.max(Math.round(maxRuns / 10), 10);
    for (let runs = 0; runs <= maxRuns; runs += step) {
      const minutesPerDay = runs * inputs.avgRuntimeMins;
      const ghMonthly = minutesPerDay * inputs.ghMinuteCost * 30;
      const nimbusMonthly = (minutesPerDay * inputs.nimbusMinuteCost + (minutesPerDay / 60) * inputs.hardwareCostPerHour) * 30;
      points.push({ runsPerDay: runs, ghMonthly, nimbusMonthly });
    }
    return points;
  }, [inputs]);

  const handleChange = (field: keyof RoiInputs) => (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = Number(event.target.value);
    setInputs((prev) => ({
      ...prev,
      [field]: Number.isFinite(value) ? value : 0,
    }));
  };

  const handleDownloadCsv = () => {
    const rows = [
      ["runs_per_day", "gh_monthly_cost", "nimbus_monthly_cost"],
      ...series.map((point) => [point.runsPerDay.toFixed(0), point.ghMonthly.toFixed(2), point.nimbusMonthly.toFixed(2)]),
    ];
    const csv = rows.map((row) => row.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = "nimbus-roi.csv";
    document.body.appendChild(anchor);
    anchor.click();
    document.body.removeChild(anchor);
    URL.revokeObjectURL(url);
  };

  const terraformSuggestion = useMemo<TerraformSuggestion>(() => {
    const totalMinutesPerDay = inputs.runsPerDay * inputs.avgRuntimeMins;
    const targetUtilisationMinutes = 8 * 60; // assume 8 productive hours per agent
    const desiredCapacity = Math.max(1, Math.ceil(totalMinutesPerDay / targetUtilisationMinutes));
    const snippet = [
      "# Suggested values generated by the ROI calculator",
      `agent_instance_type = "t3.large"`,
      `agent_desired_capacity = ${desiredCapacity}`,
    ].join("\n");
    const comment =
      "Assuming ~8 productive hours per agent each day. Tweak the instance type or desired capacity to match your workload.";
    return {
      desiredCapacity,
      comment,
      snippet,
    };
  }, [inputs]);

  const handleCopyTerraform = () => {
    void navigator.clipboard.writeText(terraformSuggestion.snippet);
  };

  return (
    <div className="tools__container">
      <header className="tools__header">
        <div>
          <h1>Tools & ROI</h1>
          <p>Estimate the operational savings of running evaluations on Nimbus.</p>
        </div>
      </header>

      <section className="tools__section">
        <h2>Compute ROI</h2>
        <div className="tools__grid">
          <label>
            Runs per day
            <input type="number" min="1" value={inputs.runsPerDay} onChange={handleChange("runsPerDay")} />
          </label>
          <label>
            Avg runtime (min)
            <input type="number" min="1" step="0.1" value={inputs.avgRuntimeMins} onChange={handleChange("avgRuntimeMins")} />
          </label>
          <label>
            GH Actions cost/min
            <input type="number" min="0" step="0.0001" value={inputs.ghMinuteCost} onChange={handleChange("ghMinuteCost")} />
          </label>
          <label>
            Nimbus cost/min
            <input type="number" min="0" step="0.0001" value={inputs.nimbusMinuteCost} onChange={handleChange("nimbusMinuteCost")} />
          </label>
          <label>
            Hardware cost/hour
            <input type="number" min="0" step="0.1" value={inputs.hardwareCostPerHour} onChange={handleChange("hardwareCostPerHour")} />
          </label>
          <label>
            GH queue latency (min)
            <input type="number" min="0" step="0.1" value={inputs.ghQueueLatencyMins} onChange={handleChange("ghQueueLatencyMins")} />
          </label>
          <label>
            Nimbus queue latency (min)
            <input type="number" min="0" step="0.1" value={inputs.nimbusQueueLatencyMins} onChange={handleChange("nimbusQueueLatencyMins")} />
          </label>
        </div>
      </section>

      <section className="tools__section">
        <h2>Results</h2>
        <div className="tools__results-grid">
          <ResultCard label="GitHub Actions monthly cost" value={`$${result.ghMonthlyCost.toFixed(2)}`} />
          <ResultCard label="Nimbus monthly cost" value={`$${result.nimbusMonthlyCost.toFixed(2)}`} />
          <ResultCard label="Annual savings" value={`$${result.annualSavings.toFixed(2)}`} emphasize />
          <ResultCard label="Time saved per eval" value={`${result.timeSavedPerEval.toFixed(1)} minutes`} />
          <ResultCard label="Breakeven" value={result.breakevenLabel} />
        </div>
      </section>

      <section className="tools__section">
        <div className="tools__chart-header">
          <h2>Cost comparison</h2>
          <button type="button" onClick={handleDownloadCsv} className="tools__download">
            Download CSV
          </button>
        </div>
        <CostChart points={series} />
      </section>

      <section className="tools__section">
        <h2>Next steps</h2>
        <ul className="tools__next">
          <li>
            Export the numbers with <code>uv run python tools/roi_calculator.py</code> for executive decks.
          </li>
          <li>
            Pair this with the migration example in <code>examples/github-actions-migration</code> to quantify savings.
          </li>
          <li>
            Tune the cache hit ratios via the dashboardâ€™s cache performance cards to squeeze runtime further.
          </li>
        </ul>
      </section>

      <section className="tools__section">
        <div className="tools__chart-header">
          <h2>Terraform autoscaling snippet</h2>
          <button type="button" onClick={handleCopyTerraform} className="tools__download">
            Copy snippet
          </button>
        </div>
        <p className="tools__terraform-comment">{terraformSuggestion.comment}</p>
        <pre className="tools__terraform-snippet">
{terraformSuggestion.snippet}
        </pre>
      </section>
    </div>
  );
}

function ResultCard({ label, value, emphasize }: { label: string; value: string; emphasize?: boolean }) {
  return (
    <article className={emphasize ? "tools__result-card tools__result-card--emphasize" : "tools__result-card"}>
      <span className="tools__result-label">{label}</span>
      <span className="tools__result-value">{value}</span>
    </article>
  );
}

function CostChart({ points }: { points: CostPoint[] }) {
  if (points.length === 0) {
    return <p className="tools__empty">No data.</p>;
  }

  const width = 600;
  const height = 240;
  const padding = 40;
  const maxCost = Math.max(...points.map((p) => Math.max(p.ghMonthly, p.nimbusMonthly)), 1);
  const maxRuns = Math.max(...points.map((p) => p.runsPerDay), 1);

  const scaleX = (runs: number) => padding + (runs / maxRuns) * (width - padding * 2);
  const scaleY = (cost: number) => height - padding - (cost / maxCost) * (height - padding * 2);

  const toPath = (selector: (point: CostPoint) => number) =>
    points
      .map((point, index) => {
        const prefix = index === 0 ? "M" : "L";
        return `${prefix}${scaleX(point.runsPerDay)},${scaleY(selector(point))}`;
      })
      .join(" ");

  return (
    <svg
      className="tools__chart"
      viewBox={`0 0 ${width} ${height}`}
      role="img"
      aria-label="Monthly cost comparison between GitHub Actions and Nimbus"
    >
      <line x1={padding} y1={height - padding} x2={width - padding} y2={height - padding} className="tools__chart-axis" />
      <line x1={padding} y1={padding} x2={padding} y2={height - padding} className="tools__chart-axis" />
      <path d={toPath((p) => p.ghMonthly)} className="tools__chart-line tools__chart-line--gh" />
      <path d={toPath((p) => p.nimbusMonthly)} className="tools__chart-line tools__chart-line--nimbus" />
      <g className="tools__chart-legend" transform={`translate(${padding},${padding - 16})`}>
        <LegendSwatch className="tools__chart-line--gh" label="GitHub Actions" />
        <LegendSwatch className="tools__chart-line--nimbus" label="Nimbus" />
      </g>
    </svg>
  );
}

function LegendSwatch({ className, label }: { className: string; label: string }) {
  return (
    <span className="tools__legend-item">
      <span className={`tools__legend-swatch ${className}`} />
      {label}
    </span>
  );
}
